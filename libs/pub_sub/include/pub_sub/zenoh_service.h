#ifndef ZENOH_SERVICE_H_
#define ZENOH_SERVICE_H_

#include <functional>
#include <optional>
#include <string>

#include <zenoh.hxx>
#include "pub_sub/session_manager.h"
#include <capnp/message.h>
#include <capnp/serialize.h>
#include <cstring>

#include "pub_sub/schema_registry.h"

#include "spdlog/spdlog.h"

namespace pub_sub
{

// Generic Cap'n Proto-backed queryable service.
// RequestT, ResponseT are Cap'n Proto structs generated by capnp.
// Handler: void(const RequestT::Reader&, ResponseT::Builder&)
template <typename RequestT, typename ResponseT>
class ZenohService
{
  public:
    using RequestReader = typename RequestT::Reader;
    using ResponseBuilder = typename ResponseT::Builder;
    using Handler = std::function<void(const RequestReader&, ResponseBuilder&)>;

    ZenohService(std::string keyexpr, Handler handler) :
        mKeyExpr(std::move(keyexpr)),
        mHandler(std::move(handler)),
        mSession(pub_sub::SessionManager::getOrCreate())
    {
        
        auto on_query = [this](const zenoh::Query& query)
        {
            // Decode request (if any)
            capnp::MallocMessageBuilder respBuilder;
            auto resp = respBuilder.template initRoot<ResponseT>();

            if (auto payloadRef = query.get_payload())
            {
                const auto& bytes = payloadRef->get();
                auto v = bytes.as_vector();
                if (v.size() % sizeof(capnp::word) == 0)
                {
                    auto words = kj::arrayPtr(reinterpret_cast<const capnp::word*>(v.data()), v.size() / sizeof(capnp::word));
                    capnp::FlatArrayMessageReader reader(words);
                    auto req = reader.template getRoot<RequestT>();
                    SPDLOG_DEBUG("Received request for key '{}' = {}", mKeyExpr, req.toString().flatten().cStr());
                    mHandler(req, resp);
                }
                else
                {
                    // Payload malformed; handler not invoked. Respond with default-constructed response.
                    SPDLOG_ERROR("Payload malformed for key '{}'", mKeyExpr);
                }
            }
            else
            {
                SPDLOG_ERROR("No payload for key '{}'", mKeyExpr);
            }

            SPDLOG_DEBUG("Sending response to key '{}' = {}", mKeyExpr, resp.toString().flatten().cStr());

            // Serialize and reply
            kj::Array<capnp::word> respWords = capnp::messageToFlatArray(respBuilder);
            kj::ArrayPtr<const kj::byte> respBytesView = respWords.asBytes();
            std::vector<uint8_t> respBytes(respBytesView.size());
            std::memcpy(respBytes.data(), respBytesView.begin(), respBytesView.size());

            zenoh::Query::ReplyOptions ropts = zenoh::Query::ReplyOptions::create_default();
            ropts.encoding.emplace("application/capnp");
            ropts.encoding->set_schema(std::string(schema_traits<ResponseT>::name));
            query.reply(mKeyExpr, zenoh::Bytes(std::move(respBytes)), std::move(ropts));
        };

        auto on_drop = []() {};

        mQueryable = mSession->declare_queryable(
            zenoh::KeyExpr(mKeyExpr),
            on_query,
            on_drop,
            zenoh::Session::QueryableOptions::create_default()
        );
    }

    ~ZenohService()
    {
        if (mQueryable.has_value())
        {
            std::move(mQueryable.value()).undeclare();
            mQueryable.reset();
        }
    }

    ZenohService(const ZenohService&) = delete;
    ZenohService& operator=(const ZenohService&) = delete;
    ZenohService(ZenohService&&) noexcept = default;
    ZenohService& operator=(ZenohService&&) noexcept = delete;

private:
    std::string mKeyExpr;
    Handler mHandler;
    std::optional<zenoh::Queryable<void>> mQueryable;
    std::shared_ptr<zenoh::Session> mSession;
};

} // namespace pub_sub

#endif // ZENOH_SERVICE_H_


