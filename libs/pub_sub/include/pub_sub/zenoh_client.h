#ifndef ZENOH_CLIENT_H_
#define ZENOH_CLIENT_H_

#include <optional>
#include <string>
#include <vector>

#include <zenoh.hxx>
#include <zenoh/api/channels.hxx>
#include <capnp/message.h>
#include <capnp/serialize.h>
#include <cstring>

#include "pub_sub/schema_registry.h"
#include "pub_sub/session_manager.h"

namespace pub_sub
{

// Generic Cap'n Proto-backed GET client.
// RequestT, ResponseT are Cap'n Proto structs generated by capnp.
template <typename RequestT, typename ResponseT>
class ZenohClient
{
  public:
    using RequestReader = typename RequestT::Reader;
    using ResponseReader = typename ResponseT::Reader;

    ZenohClient(const std::string& keyexpr, uint64_t timeoutMs) :
        mSession(zenoh_session_manager::SessionManager::getOrCreate()),
        mRequest(mBuilder.template initRoot<RequestT>()),
        mKeyExpr(keyexpr),
        mTimeoutMs(timeoutMs)
    {
    }

    // Accessor to the owned request builder
    typename RequestT::Builder& fields()
    {
        return mRequest;
    }

    // Overload that uses the internally owned Request builder
    template <typename Handler>
    bool request(Handler&& on_response)
    {
        // Serialize request from internal builder
        kj::Array<capnp::word> reqWords = capnp::messageToFlatArray(mBuilder);
        kj::ArrayPtr<const kj::byte> reqBytesView = reqWords.asBytes();
        std::vector<uint8_t> reqBytes(reqBytesView.size());
        std::memcpy(reqBytes.data(), reqBytesView.begin(), reqBytesView.size());

        zenoh::Session::GetOptions opts = zenoh::Session::GetOptions::create_default();
        opts.timeout_ms = mTimeoutMs;
        opts.payload.emplace(std::move(reqBytes));
        opts.encoding.emplace("application/capnp");
        opts.encoding->set_schema(std::string(schema_traits<RequestT>::name));

        // Channel-based blocking get
        zenoh::channels::FifoChannel channel(4);
        zenoh::ZResult err = Z_OK;
        auto handler = mSession->get(zenoh::KeyExpr(mKeyExpr), "", channel, std::move(opts), &err);
        if (err != Z_OK)
        {
            SPDLOG_ERROR("Failed to get from key '{}': {}", mKeyExpr, err);
            return false;
        }

        SPDLOG_DEBUG("Sent request to key '{}' = {}", mKeyExpr, mRequest.toString().flatten().cStr());

        // Drain replies; pass first OK response to callback
        while (true)
        {
            auto received = handler.recv();
            if (std::holds_alternative<zenoh::Reply>(received))
            {
                zenoh::Reply reply = std::move(std::get<zenoh::Reply>(received));
                if (reply.is_ok())
                {
                    const auto& sample = reply.get_ok();
                    auto v = sample.get_payload().as_vector();
                    if (v.size() % sizeof(capnp::word) == 0)
                    {
                        auto words = kj::arrayPtr(reinterpret_cast<const capnp::word*>(v.data()), v.size() / sizeof(capnp::word));
                        capnp::FlatArrayMessageReader reader(words);
                        auto resp = reader.template getRoot<ResponseT>();
                        SPDLOG_DEBUG("Received response from key '{}' = {}", mKeyExpr, resp.toString().flatten().cStr());
                        on_response(resp);
                        return true;
                    }
                }
            }
            else
            {
                auto recv_err = std::get<zenoh::channels::RecvError>(received);
                if (recv_err == zenoh::channels::RecvError::Z_DISCONNECTED)
                {
                    break;
                }
            }
        }

        SPDLOG_ERROR("No response received from key '{}'", mKeyExpr);
        return false;
    }

  private:
    std::shared_ptr<zenoh::Session> mSession;
    capnp::MallocMessageBuilder mBuilder;
    typename RequestT::Builder mRequest;
    std::string mKeyExpr;
    uint64_t mTimeoutMs;
};

} // namespace pub_sub

#endif // ZENOH_CLIENT_H_

